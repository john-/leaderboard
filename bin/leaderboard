#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use File::Temp;    # names for tts files

my $config = plugin Config => { file => '../config/leaderboard.conf' };

app->plugin('RenderFile');
app->plugin('CORS');
app->plugin('ForkCall');    # used to have swift not block

app->secrets( ['Specfying a secret to make the reminder go away.'] );

app->defaults( ua => Mojo::UserAgent->new );

get '/self' => sub {
    my $c = shift;

    $c->render( json => { function => 'Leaderboard' } );

# ugh this is nasty but I need to store it here because it does not work in the helper
    app->defaults->{audio_url} = $c->url_for('audio')->to_abs;
};

get '/script' => { template => 'script' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath'            => "../archive/$file",
        'content_disposition' => 'inline'
    );
};

get '/standings' => sub {
    my $c = shift;

    $c->render( json => app->defaults->{field} );
};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    my $client =
      $c->tx->remote_address . $c->tx->remote_port;    # unique identifier
        # TODO: delete this on connection close

    $c->send( { json => app->config_msg } );

    #app->defaults->{announce_sub}{$client} = [];

    #my $trans_ref = 0;
    my $id        = Mojo::IOLoop->recurring(
        1 => sub {
            my $loop = shift;

	    while ( my $msg = app->get_msg($client) )
            {
                $c = $c->send( { json => $msg } );
                app->log->info("item to let client know about: $msg->{type}");
            }
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

	    if ( $hash->{type} eq 'set_series' ) {
		app->set_series( $hash->{series} );
            } elsif ( $hash->{type} eq 'set_rate' ) {
		app->set_rate( $hash->{rate} );
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed ($code)");
        }
    );

};

helper config_msg => sub {
    my $self = shift;

    # TODO: Not all $config data needs to go to client (urls, etc).
    return { type => 'config', %{ $config }, series => app->defaults->{series} };
};

helper get_msg => sub {
    my ( $self, $client ) = @_;

    return shift @{ app->defaults->{announce_sub}{$client} };
};

helper publish => sub {
    my ( $self, $msg ) = @_;

    push @$_, $msg
      for values %{ app->defaults->{announce_sub} };
};

helper cancel_cur_req => sub {

    foreach (keys %{ app->defaults->{loop_ids} }) {
        app->log->info(sprintf('cleaning up timer (%s)', $_));
        Mojo::IOLoop->remove( app->defaults->{loop_ids}{$_} );
        delete app->defaults->{loop_ids}{$_};
    }
};

helper set_series => sub {
    my ( $self, $series ) = @_;

    app->log->info("series: $series");

    app->cancel_cur_req;

    app->defaults->{series}         = $series;
    app->defaults->{update_counter} = 1;
    app->defaults->{prev_field}     = {};
    app->defaults->{prev_session}   = {};
    #app->defaults->{announce_sub}   = {};   # this should not go here...maybe someplace else
    app->publish( app->config_msg );

    app->get_all_boards if app->defaults->{series} ne 'Off';
};

helper set_rate => sub {
    my ( $self, $rate ) = @_;

    app->log->info("rate: $rate");

    app->cancel_cur_req;

    $config->{rate} = $rate;
    app->get_all_boards;

    app->publish( app->config_msg );
};

helper get_all_boards => sub {

    foreach my $lboard ( @{ $config->{boards}{ app->defaults->{series} } } ) {
	app->get_board($lboard);
    }

};

helper get_board => sub {
    my ($self, $lboard) = @_;

    #app->log->info(dumper($lboard));
    my $url = $lboard->{url};
    app->defaults->{ua}->get(
        $url => sub {
            my ( $ua, $tx ) = @_;

            app->log->info(sprintf('requesting page (%s)...', $lboard->{purpose}));
            my $rate = $config->{rate};
            if ( my $res = $tx->success ) {
                app->log->info(sprintf('got response (%s)', $lboard->{purpose}));

                #print Dumper($tx->res->json);
                my $parser = $lboard->{purpose} . '_parser';

                Mojo::IOLoop->next_tick( sub { app->$parser($tx, $lboard) } );

                app->record_file( $tx->res->to_string );

            }
            else {
                my $err = $tx->error;
                $rate = 3;
                app->log->error(sprintf(
                  'could not retrieve page (%s): %s', $lboard->{purpose},$err->{message}));
            }

            app->defaults->{loop_ids}{ $lboard->{purpose} } =
              Mojo::IOLoop->timer( $rate => sub { app->get_board($lboard) } );

        }
    );

};

helper record_file => sub {
    my ( $self, $content ) = @_;

    my $file = sprintf(
        '../archive/leaderboards/%s-%s-%s.raw',
        app->defaults->{series},
        $$, app->defaults->{update_counter}
    );

    app->log->info("archive: $file");

    open my $fh, '>>', $file
      or app->log->error("Can't open $file: $!");

    print $fh $content;

    close $fh or app->log->error("Can't close $file: $!");

    app->defaults->{update_counter}++;
};

helper tudor_standings_parser => sub {
    my ( $self, $tx, $lboard ) = @_;

    #print "in the parsing function: ".Dumper($tx->res->json)."\n";

    # parse

    my %tablemap = %{ $lboard->{tablemap} };

    delete app->defaults->{field};

    foreach my $row ( @{ $tx->res->json->{B} } ) {
        my $pos;
        foreach my $key ( keys %tablemap ) {
            $pos->{ $tablemap{$key} } = $row->{$key};

# TODO:  Cleanups.  For example remove leading space from driver names, convert time

        }
        push @{ app->defaults->{field} }, $pos;
    }

    #print Dumper(app->defaults->{field});

    # let ui bit know about potentially new stuff and do tts on interesting bits
    Mojo::IOLoop->next_tick( sub { app->review_field } );

};

helper review_field => sub {
    my $self = shift;

    app->log->info('Reviewing field for changes');

    my %prev_field = %{ app->defaults->{prev_field} };

    foreach my $pos ( @{ app->defaults->{field} } ) {
        if ( defined $prev_field{ $pos->{car} } ) {
            my %prev_pos = %{ $prev_field{ $pos->{car} } };

            # look at each key for interesting things and report on them
            foreach my $prop ( keys %$pos ) {
                if ( !app->renderer->get_helper($prop) ) { next }
                if ( my $change =
                    app->$prop( $prev_pos{$prop}, $pos->{$prop} ) )
                {
                    push @{ $pos->{changes} }, $change;
                }
            }
            if ( $pos->{changes} ) {
                app->announce($pos);

                #app->log->info(dumper($pos));
            }
        }
        app->defaults->{prev_field}{ $pos->{car} } = $pos;
    }

    # tell clients there is update ready
    app->publish( { type => 'update' } );
};

helper tudor_session_parser => sub {
    my ( $self, $tx, $lboard ) = @_;

    # parse

    my %tablemap = %{ $lboard->{tablemap} };

    delete app->defaults->{session};

    my $session;
    foreach my $key ( keys %tablemap ) {
        $session->{ $tablemap{$key} } = $tx->res->json->{$key};
    }

    # cleanup data
    my %flag_lookup = (
	0 => 'No Status',
	1 => 'Green',
	2 => 'Yellow',
	3 => 'Red',
	4 => 'Checkered',
	5 => 'White'
    );
    $session->{flag} = $flag_lookup{ $session->{flag} };

    app->defaults->{session} = $session;

    app->log->debug(dumper(app->defaults->{session}));

    # let ui bit know about potentially new stuff and do tts on interesting bits
    Mojo::IOLoop->next_tick( sub { app->review_session } );


};

helper review_session => sub {
    my $self = shift;

    app->log->info('Reviewing session for changes');

    my %prev_session = %{ app->defaults->{prev_session} };
    my %session      = %{ app->defaults->{session} };

    # look for changes and report

    if ( (defined $prev_session{flag}) && ($prev_session{flag} ne $session{flag}) ) {
	app->log->info("flag is now $session{flag}");
    }

    app->defaults->{prev_session} = app->defaults->{session};

};

helper position => sub {
    my ( $self, $prev, $cur ) = @_;

    my $change;
    if ( $prev > $cur ) {
        $change = 'position_improve';
    }
    elsif ( $prev < $cur ) {
        $change = 'position_deprove';
    }

    return $change;
};

helper announce => sub {
    my ( $self, $car_ref ) = @_;

    my %car = %$car_ref;

    app->log->info( sprintf( 'car update: %s', $car{driver} ) );

    my %utts = (
        position_improve => {
            speaker => 'Diane',
            phrase  => '$car{driver} P$car{position}'
        },
        status_pit => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} pitted'
        },
        status_fin => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} finished'
        },
        status_ret => {
            speaker => 'Diane',
            phrase  => '$car{driver} retired'
        },
        driver => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} in car $car{car}'
        },
        best_lap_overall => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best lap $car{last_lap_words}'
        },
        best_lap_p1 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best P1 lap $car{last_lap_words}'
        },
        best_lap_p2 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best P2 lap $car{last_lap_words}'
        },
        best_lap_gt1 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best GT1 lap $car{last_lap_words}'
        },
        best_lap_gt2 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best GT2 lap $car{last_lap_words}'
        },
        best_speed_overall => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best speed $car{best_speed}'
        },
        best_speed_p1 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best P1 speed $car{best_speed}'
        },
        best_speed_p2 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best P2 speed $car{best_speed}'
        },
        best_speed_gt1 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best GT1 speed $car{best_speed}'
        },
        best_speed_gt2 => {
            speaker => 'Lawrence',
            phrase  => '$car{driver} best GT2 speed $car{best_speed}'
        },
    );

    foreach ( @{ $car{changes} } ) {
        if ( defined $utts{$_} ) {
            my $utterance =
              "<voice name=\"$utts{$_}{speaker}\">$utts{$_}{phrase}</voice>\n";
            $utterance =~ s/\$car\{(\w+)\}/$car{$1}/g;
            app->log->info( sprintf( 'utterance: %s', $utterance ) );

            my $tmp = File::Temp->new(
                TEMPLATE => 'temp-XXXXX',
                DIR      => '../archive/audio',
                SUFFIX   => '.audio'
            );
            my $filename = $tmp->filename;

            my @args = ( '/opt/swift/bin/swift', '-o', $filename, $utterance );
            $self->fork_call(
                sub {
                    my $detail = {
                        type       => 'audio',
                        driver     => $car{driver},
                        file       => $filename,
                        start      => time(),
                        designator => $utterance,
                        url        => app->defaults->{audio_url},
                    };

                    system(@args);
                    return $detail;
                },
                sub {
                    my ( $c, $detail ) = @_;

                    app->publish( $detail );

                    #app->log->info("returned with: " . dumper(@return));
                }
            );

        }

    }

};

app->set_series('Off');
#app->set_series('TUDOR');

#Mojo::IOLoop->timer( 3 => sub { app->set_series } );

app->start;

__DATA__

@@ script.html.ep
console.log("Leaderboard code running");

var lboard_ws = new WebSocket('<%= url_for('output')->to_abs %>');

setInterval(function () {
        scan_ws.send(JSON.stringify( { type: "ping" } ));
        }, 45000
);

var lboard_config;
lboard_ws.onmessage = function (event) {
    var msg = $.parseJSON(event.data);

    switch (msg.type) {
        case 'audio':
            enqueue(msg);
            break;
        case 'update':
            leaderboard_page();
            break;
        case 'config':
            lboard_config = msg;
            lboard_config.boards.Off = 'dummy series';
            break;
    }

};

leaderboard_page = function () {

    // TODO: this is pretty convoluted and better way should be found
    var active_id = $("#switcher").tabs("option", "active");
    active = $("#switcher ul>li a").eq(active_id).attr('href');

    if (active != '#leaderboard') { return }

    console.log("Populating leaderboard page");

    $.getJSON( '<%= url_for('standings')->to_abs %>' )
        .done(function( json ) {
   	    $('#leaderboard').empty().append('<ol data-role="listview" id="standings"></ol>');

	    json.forEach( function(pos) {

                    var contents = '<h2>' + pos.driver + '</h2><p>' + 
                                  pos.class + '</p><div class="ui-li-aside"><p>Interval: ' +
                                  pos.interval + '</p><p>Gap: ' + pos.gap + '</p></div>';

		    $('<li/>')
		        .append(
		  	    $('<a/>', {
			        html: contents,
			        href: "#" + pos.car
			    })
			    ).appendTo("#standings");

                //console.log(pos)
            });

            // There may be another way but this appears to work:
            // http://www.gajotres.net/uncaught-error-cannot-call-methods-on-prior-to-initialization-attempted-to-call-method-refresh/
            $('#standings').listview().listview('refresh');

        });
};

leaderboard_config = function() {

    // approach from: http://stackoverflow.com/questions/16015810/jquery-mobile-best-way-to-create-pop-up-and-content-dynamically

    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : "Leaderboard Configuration"
    }).appendTo($config);

    $('<form id="container">').append(
        $('<label>', {
            for: 'rate',
            text: 'Refresh rate',
    }))
    .append($('<input/>', {
        type : 'range',
        name : 'rate',
        id : 'rate',
        value : lboard_config.rate,
        min : '0',
        max : '60'
    })).appendTo($config);

    $('<label>', {
        for: 'series',
        text : 'Series',
        class: 'select'
    }).appendTo('#container');

    $('#container').append('<select name="series" id="lboards"></select>');

    $.each( lboard_config.boards, function(name, detail) {
       $('<option/>', {
		        text: name,
		        value: name
		    })
		    .appendTo("#lboards");
    });

    //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        check_for_lboard_changes();
        //that.subscribeToAsset(callback);
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);


    $('#lboards').val( lboard_config.series );

    $config.popup("open").trigger("create");
};

check_for_lboard_changes = function() {

    if ( $('#rate').val() != lboard_config.rate ) {
        lboard_ws.send(JSON.stringify( { type: "set_rate", rate: $('#rate').val() } ));             }
    if ( $('#lboards').val() != lboard_config.series ) {
        lboard_ws.send(JSON.stringify( { type: "set_series", series: $('#lboards').val() } ));    }

};
