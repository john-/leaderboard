#!/usr/bin/env perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Util qw(dumper);
use Linux::Inotify2;

my $config = plugin Config => {file => '../config/leaderboard.conf'};

app->plugin('CORS');
app->plugin('ForkCall');   # used to have swift not block

app->defaults( ua => Mojo::UserAgent->new );

get '/' => { template => 'index' };

get '/self' => sub {
    my $c    = shift;

    $c->render(json => { function => 'Leaderboard' } );
};

get '/script' => { template => 'script' };

get '/standings' => sub {
    my $c    = shift;

    $c->render(json => app->defaults->{field});
};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    my $id = $c->tx->remote_address . $c->tx->remote_port;
    # TODO: delete this on connection close
    app->defaults->{announce_sub}{$id};
    app->log->info(sprintf('orig: %s-%s', $c->tx->remote_address, $c->tx->remote_port));
    #app->log->info('loop_id (orig): ' . app->defaults->{loop_id});

    my $trans_ref = 0;
    my $id        = Mojo::IOLoop->recurring(
        1 => sub {
            my $loop = shift;

	    foreach (@{app->defaults->{announce_sub}{$id}}) {
		my $item = shift @{app->defaults->{announce_sub}{$id}};
		app->log->info("item to let client know about: " . dumper($item));
            };

            if ( $trans_ref == app->defaults->{update_counter} ) { return }

            #my %details = %{ app->defaults('state') };

            $c = $c->send( { json => { type => 'update' } } );
            app->log->info(
                sprintf( 'let client know about update' ) );
            $trans_ref = app->defaults->{update_counter};
        }
    );

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

            if ( $hash->{type} eq 'rate' ) {
                app->log->info(
                    sprintf( 'Request to change rate to %s', $hash->{rate} ) );

                # TODO:  Change rate, series, etc.
                #app->update_pass( $hash->{freq}, $hash->{designator} );
                #$c->start_rtlfm;
            }

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            Mojo::IOLoop->remove($id);
            $c->app->log->debug("WebSocket closed with status $code.");
        }
    );


};

helper set_series => sub {
    my ($self, $series) = @_;

    if ( exists app->defaults->{loop_id} ) {
        app->log->info("cleaning up timer");
        Mojo::IOLoop->remove( app->defaults->{loop_id} );
        delete app->defaults->{loop_id};
    }

    app->defaults->{series} = $series;
    app->defaults->{update_counter} = 1;
    app->defaults->{prev_field} = {};
    app->defaults->{announce_sub} = {};
    app->get_board;
};

helper get_board => sub {

    app->log->info('requesting page...');
    #print Dumper($config);
    my $url = $config->{boards}{app->defaults->{series}}{url};
    app->defaults->{ua}->get(
        $url => sub {
            my ( $ua, $tx ) = @_;

	    my $rate = $config->{rate};
	    if (my $res = $tx->success) { 
                app->log->info('got response and ready to parse');
                #print Dumper($tx->res->json);
		my $parser = $config->{boards}{app->defaults->{series}}{parser};

		Mojo::IOLoop->next_tick( sub { app->$parser($tx) });

		app->record_file($tx->res->to_string);

	    } else {
		my $err = $tx->error;
		$rate = 3;
		app->log->error("$err->{code} response: $err->{message}") if $err->{code};
            }
          
            app->defaults->{loop_id} =
              Mojo::IOLoop->timer( $rate => sub { app->get_board } );

        }
    );

};

helper record_file => sub {
    my ($self, $content) = @_;


    my $file = sprintf ('../archive/leaderboards/%s-%s-%s.raw',
			app->defaults->{series}, $$, app->defaults->{update_counter});

    app->log->info("archive: $file");

    open my $fh, '>>', $file
	or app->log->error("Can't open $file: $!");

    print $fh $content;

    close $fh or app->log->error("Can't close $file: $!");

    # TODO: might be timing issue doing this here as this is what triggers possible UI update
    app->defaults->{update_counter}++;
};


helper tudor_parser => sub {
    my ($self, $tx) = @_;

    #print "in the parsing function: ".Dumper($tx->res->json)."\n";

    # parse

    my %tablemap = %{$config->{boards}{app->defaults->{series}}{tablemap}};

    delete app->defaults->{field};

    foreach my $row (@{$tx->res->json->{B}}) {
	my $pos;
	foreach my $key (keys %tablemap) {
	    $pos->{$tablemap{$key}} = $row->{$key};

	    # TODO:  Cleanups.  For exmaple remove leading space from driver names, convert time

	};
	push @{app->defaults->{field}}, $pos;
    };

    #print Dumper(app->defaults->{field});

    # let ui bit know about potentially new stuff and do tts on interesting bits
    Mojo::IOLoop->next_tick( sub { app->review_field });

};

helper review_field => sub {
    my $self = shift;

    app->log->info('Reviewing field for changes');

    my %prev_field = %{app->defaults->{prev_field}};

    foreach my $pos (@{app->defaults->{field}}) {

	if (defined $prev_field{$pos->{car}}) {

	    my %prev_pos = %{$prev_field{$pos->{car}}};

	    # look at each key for interesting things and report on them

	    foreach my $prop (keys %$pos) {

		if (!app->renderer->get_helper($prop)) { next }

		if (my $change = app->$prop($prev_pos{$prop}, $pos->{$prop})) {
		    push @{$pos->{changes}}, $change;
		}

	    }

            if ($pos->{changes}) {
	        app->announce($pos);
	        #app->log->info(dumper($pos));
            }

	}

        app->defaults->{prev_field}{$pos->{car}} = $pos;

    };
};

helper announce => sub {
    my ($self, $car_ref) = @_;

    my %car = %$car_ref;

    app->log->info(sprintf('car update: %s', $car{driver}));

    my %utts = (  position_improve => 
                   {  speaker => 'Diane',
                      phrase => '$car{driver} P$car{position}'
		   },
                  status_pit =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} pitted'
		   },
                  status_fin =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} finished'
		   },
                  status_ret =>
	           {  speaker => 'Diane',
                      phrase => '$car{driver} retired'
		   },
                  driver =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} in car $car{car}'
		   },
                  best_lap_overall =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best lap $car{last_lap_words}'
		   },
                  best_lap_p1 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best P1 lap $car{last_lap_words}'
		   },
                  best_lap_p2 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best P2 lap $car{last_lap_words}'
		   },
                  best_lap_gt1 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best GT1 lap $car{last_lap_words}'
		   },
                  best_lap_gt2 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best GT2 lap $car{last_lap_words}'
		   },
                  best_speed_overall =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best speed $car{best_speed}'
		   },
                  best_speed_p1 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best P1 speed $car{best_speed}'
		   },
                  best_speed_p2 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best P2 speed $car{best_speed}'
		   },
                  best_speed_gt1 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best GT1 speed $car{best_speed}'
		   },
                  best_speed_gt2 =>
	           {  speaker => 'Lawrence',
                      phrase => '$car{driver} best GT2 speed $car{best_speed}'
		   },
	       );


    foreach (@{$car{changes}}) {
	if (defined $utts{$_}) {
	    my $utterance = "<voice name=\"$utts{$_}{speaker}\">$utts{$_}{phrase}</voice>\n";
	    $utterance =~ s/\$car\{(\w+)\}/$car{$1}/g;
	    #$utterance =~ s/(\$car\{\w+\})/$1/gee;
	    #$kernel->yield( 'say' => $utterance );
	    app->log->info(sprintf('utterance: %s', $utterance));

	    my @args = ( '/opt/swift/bin/swift', '-o', '/tmp/out.wav', $utterance );
	    $self->fork_call(
		sub {
		    system(@args);
		    return 'blah';
	        },
		sub {
		    my ($c, @return) = @_;
		    foreach my $client (keys %{app->defaults->{announce_sub}}) {
			push @{app->defaults->{announce_sub}{$client}}, $return[0];
		    }
		        

		    app->log->info("returned with: " . dumper(@return));
                }
            );

        }

    }


};

helper position => sub {
    my ($self, $prev, $cur) = @_;

    my $change;
    if ($prev > $cur) {
	$change = 'position_improve';
    } elsif ($prev < $cur) {
	$change = 'position_deprove';
    }
	
    return $change;
};


app->set_series('TUDOR');
#Mojo::IOLoop->timer( 3 => sub { app->set_series } );

app->start;

__DATA__

@@ index.html.ep
<!DOCTYPE html>

<body>
    <script>
    alert('OUT OF DATE.  USE SEPERATE UI INSTEAD');
    //$(document).on("pagecreate",function(){

    var ws = new WebSocket('<%= url_for('output')->to_abs %>');

    //var player = document.getElementById('player');
    var chaninfo;
    var clips = [];
    ws.onmessage = function (event) {
        chaninfo = JSON && JSON.parse(event.data) || $.parseJSON(data);
        // TODO:  There will be at least two messages:  update and tts available.
        //clips.push(chaninfo);
        //$('#xmit span').text(clips.length);
        //if (clips.length == 1) { next_xmit() };
        console.log(chaninfo);
    };
    //}); 
    </script>
</body>
</html>


@@ script.html.ep
console.log("Leaderboard code running");

var lboard_ws = new WebSocket('<%= url_for('output')->to_abs %>');

lboard_ws.onmessage = function (event) {
    var msg = JSON && JSON.parse(event.data) || $.parseJSON(data);

    if (msg.type == 'audio') {
        enqueue(msg);
    } else if (msg.type == 'update') {
        leaderboard_page();
    }
};

leaderboard_page = function () {

    // TODO: this is pretty convoluted and better way should be found
    var active_id = $("#switcher").tabs("option", "active");
    active = $("#switcher ul>li a").eq(active_id).attr('href');

    if (active != '#leaderboard') { return }

    console.log("Populating leaderboard page");

    $.getJSON( '<%= url_for('standings')->to_abs %>' )
        .done(function( json ) {

   	    $('#leaderboard').empty().append('<ol data-role="listview" id="standings"></ol>');

	    json.forEach( function(pos) {

                    var contents = '<h2>' + pos.driver + '</h2><p>' + 
                                  pos.class + '</p><div class="ui-li-aside"><p>Interval: ' +
                                  pos.interval + '</p><p>Gap: ' + pos.gap + '</p></div>';

		    $('<li/>')
		        .append(
		  	    $('<a/>', {
			        html: contents,
			        href: "#" + pos.car
			    })
			    ).appendTo("#standings");

                //console.log(pos)
            });

            // There may be another way but this appears to work:
            // http://www.gajotres.net/uncaught-error-cannot-call-methods-on-prior-to-initialization-attempted-to-call-method-refresh/
            $('#standings').listview().listview('refresh');

        });

};
